<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: sockets.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>sockets.h File Reference</h1>socket layer for slim beep  
<a href="#_details">More...</a>
<p>
<code>#include "<a class="el" href="config_8h-source.html">config.h</a>"</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>
<code>#include &lt;sys/time.h&gt;</code><br>
<code>#include &lt;sys/socket.h&gt;</code><br>
<code>#include &lt;sys/select.h&gt;</code><br>
<code>#include &lt;unistd.h&gt;</code><br>
<code>#include &lt;netinet/in.h&gt;</code><br>
<code>#include &lt;netdb.h&gt;</code><br>
<code>#include &lt;errno.h&gt;</code><br>

<p>
<a href="sockets_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsbSockObject.html">sbSockObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The socket object. </em> <a href="structsbSockObject.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="sockets.h::__LIB3195_SOCKETS_H_INCLUDED__"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>__LIB3195_SOCKETS_H_INCLUDED__</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="sockets.h::sbSockCHECKVALIDOBJECT"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>sbSockCHECKVALIDOBJECT</b>(x)&nbsp;&nbsp;&nbsp;{assert(x != NULL); assert(x-&gt;OID == OIDsbSock);}</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="sockets.h::sbSOCK_NO_CHAR"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a2">sbSOCK_NO_CHAR</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value to return when no character could be read by a socket recv call. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="sockets.h::sbSockGetLastError"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a3">sbSockGetLastError</a>(pThis)&nbsp;&nbsp;&nbsp;pThis-&gt;iLastErr</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Getthe last error for this module. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a4" doxytag="sockets.h::sbSockSetLastError"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a4">sbSockSetLastError</a>(pThis, iRet)&nbsp;&nbsp;&nbsp;pThis-&gt;iLastErr = iRet</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the last error for this module. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="sockets.h::sbSockResetLastError"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a5">sbSockResetLastError</a>(pThis)&nbsp;&nbsp;&nbsp;pThis-&gt;iLastErr = SR_RET_OK</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reset the last error for this module <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a6">sbSockFD_ZERO</a>(fdset)&nbsp;&nbsp;&nbsp;FD_ZERO(fdset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">wrapper for the FD_ZERO macro. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a7">sbSockFD_SET</a>(sock, fdset)&nbsp;&nbsp;&nbsp;FD_SET(sock, fdset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the FD_SET macro. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a8">sbSockFD_ISSET</a>(sock, fdset)&nbsp;&nbsp;&nbsp;FD_ISSET(sock, fdset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the FD_ISSET macro. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="sockets.h::SBSOCK_EWOULDBLOCK"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>SBSOCK_EWOULDBLOCK</b>&nbsp;&nbsp;&nbsp;EWOULDBLOCK</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="sockets.h::SOCKET_ERROR"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>SOCKET_ERROR</b>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="sockets.h::sbSockObj"></a>
typedef <a class="el" href="structsbSockObject.html">sbSockObject</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbSockObj</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="sockets.h::srSock_fd_set"></a>
typedef fd_set&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a12">srSock_fd_set</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the fd_set data structure. <br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a13">sbSockLayerInit</a> (int bInitOSStack)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global Layer initialization. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a14">sbSockLayerExit</a> (int bExitOSStack)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global Layer destructor. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a15">sbSockInit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="sockets.h::sbSockExit"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a16">sbSockExit</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a17">sbSockGetLastSockError</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get last error code </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a18">sbSockConnectoToHost</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, char *pszHost, int iPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect a socket to a remote host. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a19">sbSockHasReceiveData</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the socket has data ready to be received. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a20">sbSockReceive</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, char *pszBuf, int iLen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive data from the socket. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a21">sbSockSend</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, const char *pszBuf, int iLen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send the supplied buffer. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a22">sbSockGetRcvChar</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the next character from the stream. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a23">sbSockPeekRcvChar</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the next character from the stream. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a24" doxytag="sockets.h::sbSockClosesocket"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a24">sbSockClosesocket</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a socket. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a25">sbSockWaitReceiveData</a> (struct <a class="el" href="structsbSockObject.html">sbSockObject</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until the socket has some receive data. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a26">sbSockSelectMulti</a> (<a class="el" href="sockets_8h.html#a12">srSock_fd_set</a> *fdsetRD, <a class="el" href="sockets_8h.html#a12">srSock_fd_set</a> *fdsetWR, int iTimOutSecs, int iTimOutMSecs, int iHighestDesc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the socket select call on a fd_set structure. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a27" doxytag="sockets.h::sbSockListen"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a27">sbSockListen</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for the socket listen() call. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a28">sbSockInitListenSock</a> (<a class="el" href="liblogging_8h.html#a6">srRetVal</a> *iRet, char *szBindToAddress, unsigned uBindToPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a listen socket. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="sockets.h::sbSockAcceptConnection"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a29">sbSockAcceptConnection</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, <a class="el" href="structsbSockObject.html">sbSockObj</a> **pNew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method accepts an incoming connection and creates a new socket object out of it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a30" doxytag="sockets.h::sbSockSetNonblocking"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a30">sbSockSetNonblocking</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the socket to nonblocking state. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a31">sbSockGetRemoteHostIP</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, char **ppszHost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the IP Address of the remote host as a string. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a32">sbSock_gethostname</a> (char **psz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for gethostname(). </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8h.html#a33">sbSockGetIPusedForSending</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, char **ppsz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide the (local) IP address this session is sending to the remote peer on as a string. </em> <a href="#a33"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
socket layer for slim beep 
<p>
This implements a very thin layer above the socket subsystem. If you intend to port the lib to a different environment, you should probably stick with that layer and create a new socketsXXX.c file.<p>
The prefix for this file is sbSock.<p>
All methods receive a pointer to their "object instance" as the first parameter.<p>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-04 0.1 version created.</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Define Documentation</h2>
<a name="a8" doxytag="sockets.h::sbSockFD_ISSET"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sbSockFD_ISSET</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sock,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>fdset&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;FD_ISSET(sock, fdset)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wrapper for the FD_ISSET macro. 
<p>
This may not work on every exotic OS, but it gives at least a small hook to porting it... Semantics are as with the original FD_ZERO.     </td>
  </tr>
</table>
<a name="a7" doxytag="sockets.h::sbSockFD_SET"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sbSockFD_SET</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sock,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>fdset&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;FD_SET(sock, fdset)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wrapper for the FD_SET macro. 
<p>
This may not work on every exotic OS, but it gives at least a small hook to porting it... Semantics are as with the original FD_ZERO.     </td>
  </tr>
</table>
<a name="a6" doxytag="sockets.h::sbSockFD_ZERO"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define sbSockFD_ZERO</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">fdset&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;FD_ZERO(fdset)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
wrapper for the FD_ZERO macro. 
<p>
This may not work on every exotic OS, but it gives at least a small hook to porting it... Semantics are as with the original FD_ZERO.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a32" doxytag="sockets.h::sbSock_gethostname"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSock_gethostname </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>psz</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wrapper for gethostname(). 
<p>
<dl compact><dt><b>Note:</b></dt><dd>The Windows sockets API seems to be broken. We often have seen that only the computer name part (not the domain name) is returned by gethostname, even if the full identity is configured. A way to work around this may be to call gethostbyname() on the returned name and then call gethostbyaddr() on what is returned there. WE HAVE NOW IMPLEMENTED THIS WORKAROUND, but leave the text above in just in case...</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>psz</em>&nbsp;</td><td>Pointer to Pointer to hostname. Must not be NULL. On return, this pointer will refer to a newly allocated buffer containing the hostname. This buffer must be free()ed by the caller! </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a18" doxytag="sockets.h::sbSockConnectoToHost"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockConnectoToHost </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszHost</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iPort</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect a socket to a remote host. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszHost</em>&nbsp;</td><td>Name or IP address of host to connect to </td></tr>
    <tr><td valign=top><em>iPort</em>&nbsp;</td><td>Port to connect to </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="sockets.h::sbSockGetIPusedForSending"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockGetIPusedForSending </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppsz</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provide the (local) IP address this session is sending to the remote peer on as a string. 
<p>
OK, the short description is probably not very well ;) What it does is, it looks up the local IP address that is used to talk to the remote Peer. This is especially important on multihomed machines, as different interfaces can be used to forward data (depending on which one is closest to the recipient). Then, it formats this as an IP Address string that then is handed back to the caller.<p>
Please note: the socket MUST be connected before you can use this method! It should NOT be used on UDP sockets.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ppsz</em>&nbsp;</td><td>Pointer to a char* that will receive the IP string. The caller must free the returned pointer when he is done. The provided pointer must not be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="sockets.h::sbSockGetLastSockError"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockGetLastSockError </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
get last error code 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>last</em>&nbsp;</td><td>error code (OS specific) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="sockets.h::sbSockGetRcvChar"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockGetRcvChar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the next character from the stream. 
<p>
The character is removed from the stream. If no data is ready on the stream, a blocking read is carried out. So this function can block!<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>character</em>&nbsp;</td><td>read </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="sockets.h::sbSockGetRemoteHostIP"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockGetRemoteHostIP </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppszHost</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the IP Address of the remote host as a string. 
<p>
The caller must free the returned string.     </td>
  </tr>
</table>
<a name="a19" doxytag="sockets.h::sbSockHasReceiveData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockHasReceiveData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the socket has data ready to be received. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>TRUE</em>&nbsp;</td><td>if data is ready, FALSE otherwise. The return value is only valid if no error occured. To make your app bullet-proof, you need to check the error indicator before using the retval... ;) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="sockets.h::sbSockInit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbSockObject.html">sbSockObj</a>* sbSockInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Returns</em>&nbsp;</td><td>a pointer to the new instance or NULL, if it could not be created. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="sockets.h::sbSockInitListenSock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbSockObject.html">sbSockObj</a>* sbSockInitListenSock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="liblogging_8h.html#a6">srRetVal</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>iRet</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>szBindToAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uBindToPort</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a listen socket. 
<p>
This includes everything so that the next call can be listen().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>iRet</em>&nbsp;</td><td>[out] Pointer to a variable holding the return code of this operation. Has the error code if initialisation failed. </td></tr>
    <tr><td valign=top><em>szBindToAdresse</em>&nbsp;</td><td>string with IP address to which the socket should be bound. If NULL, do not bind to any specific address. </td></tr>
    <tr><td valign=top><em>iBindToPort</em>&nbsp;</td><td>Port the socket should be bound to. For listening sockets, this is the port that the remote peer will to connect to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to newly created socket or NULL, if an error occured. In case of NULL, the caller can examine the socket error code to learn the error cause. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a14" doxytag="sockets.h::sbSockLayerExit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockLayerExit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bExitOSStack</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Global Layer destructor. 
<p>
Call this only once at the end of the application. All sockets must be destroyed before calling this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>bExitOSStack</em>&nbsp;</td><td>Specifies if the library should shut down the operating system socket stack. If 1, it shuts it down, if 0, it does not. Set this to 0 if you integrate this lib into an app that otherwise shuts down the OS socket lib itself. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="sockets.h::sbSockLayerInit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockLayerInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bInitOSStack</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Global Layer initialization. 
<p>
Should be called only once per application. This will do all housekeeping necessary to use the layer. DO NOT CALL ANY OTHER METHODS BEFORE THIS ONE HAS BEEN CALLED! They will probably fail!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>bInitOSStack</em>&nbsp;</td><td>Specifies if the library should initialize the operating system socket stack. If 1, it initializes it, if 0, it does not. Set this to 0 if you integrate this lib into an app that otherwise initializes the socket lib itself. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="sockets.h::sbSockPeekRcvChar"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockPeekRcvChar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the next character from the stream. 
<p>
The character is NOT removed from the stream. If no data is ready on the stream, a blocking read is carried out. So this function can block!<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>character</em>&nbsp;</td><td>read </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="sockets.h::sbSockReceive"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockReceive </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszBuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iLen</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive data from the socket. 
<p>
This is done in a blocking way. If you would not like to block, call <a class="el" href="sockets_8h.html#a19">sbSockHasReceiveData</a> before calling this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>*pszBuf</em>&nbsp;</td><td>[in] - data to be send </td></tr>
    <tr><td valign=top><em>iLen</em>&nbsp;</td><td>[in] - length of pszBuf </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>actual</em>&nbsp;</td><td>bytes sent by socket subsystem </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="sockets.h::sbSockSelectMulti"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockSelectMulti </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="sockets_8h.html#a12">srSock_fd_set</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>fdsetRD</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="sockets_8h.html#a12">srSock_fd_set</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>fdsetWR</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iTimOutSecs</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iTimOutMSecs</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iHighestDesc</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wrapper for the socket select call on a fd_set structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>iTimOutSecs</em>&nbsp;</td><td>Seconds until timeout. -1 means indefinite blocking. </td></tr>
    <tr><td valign=top><em>iTimOutMSecs</em>&nbsp;</td><td>Milliseconds until timeout. </td></tr>
    <tr><td valign=top><em>iHighestDesc</em>&nbsp;</td><td>[*NIX ONLY!] The highest file descriptor in any of the fd_sets. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Value</em>&nbsp;</td><td>returned by select. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="sockets.h::sbSockSend"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockSend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszBuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iLen</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send the supplied buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>*pszBuf</em>&nbsp;</td><td>[in] - data to be sent. If NULL, no data is sent (but NULL is a VALID value for this param!). </td></tr>
    <tr><td valign=top><em>iLen</em>&nbsp;</td><td>[in] - number of bytes to send </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>number</em>&nbsp;</td><td>of bytes actually sent </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="sockets.h::sbSockWaitReceiveData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockWaitReceiveData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structsbSockObject.html">sbSockObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait until the socket has some receive data. 
<p>
This is a blocking call.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Sep 12 11:20:14 2003 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
