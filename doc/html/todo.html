<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: Todo List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a name="todo">Todo List</a>
</h1><a name="_todo000001"/></a> <dl>
<dt>page <a class="el" href="index.html">liblogging - a slim library for reliable syslog</a>  </dt>
<dd>The linked list of profiles is thread-safe). When a profile is added, it is immediatly available for the next connection. If a profile is removed, ( <p>
implement this later!) the profile is immediately no longer be advertised in the greeting BUT it is actually removed only after the last channel using it has been closed. </dd>
</dl>
<p>
<a name="_todo000019"/></a> <dl>
<dt>Member <a class="el" href="structsrAPIObject.html#o5">srAPIObject::iUse3195Profiles</a>  </dt>
<dd>create the methods for pUsr</dd>
</dl>
<p>
<a name="_todo000002"/></a> <dl>
<dt>Member <a class="el" href="beepchannel_8c.html#a0">sbChanTeardown</a> (sbChanObj *pThis) </dt>
<dd>take care of the pending_close state here (one we do this)</dd>
</dl>
<p>
<a name="_todo000006"/></a> <dl>
<dt>Member <a class="el" href="beeplisten_8c.html#a8">sbLstnConstruct</a> (void) </dt>
<dd>get the listen addr &amp; port from config or option!</dd>
</dl>
<p>
<a name="_todo000003"/></a> <dl>
<dt>Member <a class="el" href="beeplisten_8c.html#a6">sbLstnSendFram</a> (sbLstnObj *pThis, sbSessObj *pSess) </dt>
<dd>We need to upgrade either this method (or create another one so that it will send multiple frames if multiple frames are in the send queue. Right now, this is done by the select() loop anyhow, but it may be more efficient to do it that way (or it may be not, this needs some more thinking...). </dd>
</dl>
<p>
<a name="_todo000004"/></a> <dl>
<dt>Member <a class="el" href="beeplisten_8c.html#a6">sbLstnSendFram</a> (sbLstnObj *pThis, sbSessObj *pSess) </dt>
<dd>We need to see if race conditions can occur where pChan becomes invalid but is still stored with the message. It may be a better idea to use the "normal" channel lookup methods, though they are definitely slower... For now, we use an assert and will test this well. <p>
again, referencing the channel object as done below is a little dangerous...</dd>
</dl>
<p>
<a name="_todo000005"/></a> <dl>
<dt>Member <a class="el" href="beeplisten_8c.html#a7">sbLstnServerLoop</a> (sbLstnObj *pThis) </dt>
<dd>think a little about the performance implications of the below - we may think about either doubly linking the list or having the previous element at hand (e.g. in the linked list object...). <p>
log this once we have a logging subsystem <p>
think a little about the performance implications of the below - we may think about either doubly linking the list or having the previous element at hand (e.g. in the linked list object...). <p>
check &amp; act on return value!!!! (close session? most probably...)</dd>
</dl>
<p>
<a name="_todo000007"/></a> <dl>
<dt>Member <a class="el" href="beepmessage_8c.html#a5">sbMIMEExtract</a> (char *pszInBuf, int iInBufLen, char **pszMIMEHdr, char **pszPayload) </dt>
<dd>handle empty string</dd>
</dl>
<p>
<a name="_todo000009"/></a> <dl>
<dt>Member <a class="el" href="beepsession-lstn_8c.html#a7">sbSessDoCloseMesg</a> (sbSessObj *pSess, int *pbAbort, sbProfObj *pProf, sbMesgObj *pMesg, sbNVTEObj *pEntry) </dt>
<dd>See RFC for actual close processing - we do not do this fully correct right at this time! For syslog, it should be sufficient, but there can be interop issues! </dd>
</dl>
<p>
<a name="_todo000008"/></a> <dl>
<dt>Member <a class="el" href="beepsession-lstn_8c.html#a1">sbSessLstnSendFram</a> (sbSessObj *pThis, sbFramObj *pFram, sbChanObj *pChan) </dt>
<dd>It may have some good performance impact, if we tried to send the data initially if there is no other send operation pending. That way, we would avoid en- and de-queueing the frame. But we would need to pay attention to the window! For now, we take the simpler approach - we can always performance tune once it works ;) </dd>
</dl>
<p>
<a name="_todo000011"/></a> <dl>
<dt>Member <a class="el" href="beepsession_8c.html#a8">sbSessOpenChan</a> (sbSessObj *pThis) </dt>
<dd>think if we need to shut down anything else inside the BEEP session. <p>
think if we need to shut down anything else inside the BEEP session. </dd>
</dl>
<p>
<a name="_todo000010"/></a> <dl>
<dt>Member <a class="el" href="beepsession_8c.html#a6">sbSessRecvFram</a> (sbSessObj *pThis, sbChanObj *pChan) </dt>
<dd>think about a timeout here - we could block indefinitely...</dd>
</dl>
<p>
<a name="_todo000012"/></a> <dl>
<dt>Member <a class="el" href="beepsession_8h.html#a19">sbSessCloseChan</a> (sbSessObj *pThis, struct <a class="el" href="structsbChanObject.html">sbChanObject</a> *pChan) </dt>
<dd>This method (and some of the plumbing behind) must be updated to be fully compliant to RFC 3080. </dd>
</dl>
<p>
<a name="_todo000013"/></a> <dl>
<dt>Member <a class="el" href="config_8h.html#a15">INVALID_SOCKET</a>  </dt>
<dd>verify this value is indeed invalid under *nix</dd>
</dl>
<p>
<a name="_todo000014"/></a> <dl>
<dt>Member <a class="el" href="socketsUnix_8c.html#a13">sbSockBind</a> (sbSockObj *pThis, char *pszHost, int iPort) </dt>
<dd>implement!</dd>
</dl>
<p>
<a name="_todo000015"/></a> <dl>
<dt>Member <a class="el" href="socketsWin32_8c.html#a13">sbSockBind</a> (sbSockObj *pThis, char *pszHost, int iPort) </dt>
<dd>implement!</dd>
</dl>
<p>
<a name="_todo000016"/></a> <dl>
<dt>Member <a class="el" href="srAPI_8c.html#a2">srAPIAddProfile</a> (srAPIObj *pThis, sbProfObj *pProf) </dt>
<dd>This method (and its helper FreeProf) is the same as in the beeplisten object. We may want to merge these two into a single utility method... </dd>
</dl>
<p>
<a name="_todo000017"/></a> <dl>
<dt>Member <a class="el" href="srAPI_8c.html#a6">srAPIOpenlog</a> (srAPIObj *pThis, char *pszRemotePeer, int iPort) </dt>
<dd>later, make this depending on the lib option set by the user.</dd>
</dl>
<p>
<a name="_todo000018"/></a> <dl>
<dt>Member <a class="el" href="syslogmessage_8c.html#a2">srSLMGDestroy</a> (srSLMGObj *pThis) </dt>
<dd>free memory (if needed in later releases). Currently, all memory is caller-provided, so it is also the callers job to free it. This may change, however, as the class evolves. </dd>
</dl>
<hr size="1"><address style="align: right;"><small>Generated on Fri Sep 12 11:20:15 2003 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
