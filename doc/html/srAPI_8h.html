<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: srAPI.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>srAPI.h File Reference</h1>The syslog reliable API.  
<a href="#_details">More...</a>
<p>

<p>
<a href="srAPI_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structsrAPIObject.html">srAPIObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The syslog-reliable API object. </em> <a href="structsrAPIObject.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="srAPI.h::__LIB3195_SRAPI_H_INCLUDED__"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>__LIB3195_SRAPI_H_INCLUDED__</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="srAPI.h::srAPICHECKVALIDOBJECT"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>srAPICHECKVALIDOBJECT</b>(x)&nbsp;&nbsp;&nbsp;{assert(x != NULL); assert(x-&gt;OID == OIDsrAPI);}</td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="srAPI.h::srAPIObj"></a>
typedef <a class="el" href="structsrAPIObject.html">srAPIObject</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>srAPIObj</b></td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a3">srAPIInitLib</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the liblogging library. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a4">srAPIOpenlog</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis, char *pszRemotePeer, int iPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a log session. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a5">srAPICloseLog</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a syslog raw session. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a6">srAPIExitLib</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the liblogging library. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a7">srAPISendLogmsg</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis, char *szLogmsg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a log message to the remote peer. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a8">srAPISendSLMG</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis, struct srSLMGObject *pSLMG)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a syslog message object to the remote peer. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a9">srAPISetOption</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis, SRoption iOpt, int iOptVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an library option. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a10">srAPIRunListener</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run the listener process. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a11">srAPIShutdownListener</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down the currently running listener. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a12">srAPISetUsrPointer</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pAPI, void *pUsr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the user pointer. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a13">srAPIGetUsrPointer</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pAPI, void **ppToStore)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the user pointer. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a14">srAPISetupListener</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis, void(*NewHandler)(<a class="el" href="structsrAPIObject.html">srAPIObj</a> *, struct srSLMGObject *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup the listener for this API object. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="srAPI_8h.html#a15">srAPISetMsgRcvCallback</a> (<a class="el" href="structsrAPIObject.html">srAPIObj</a> *pThis, void(*NewHandler)(<a class="el" href="structsrAPIObject.html">srAPIObj</a> *, struct srSLMGObject *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a handler to be called when a syslog message arrives. </em> <a href="#a15"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The syslog reliable API. 
<p>
This is the transport part of the API. Please be sure to also look at <a class="el" href="syslogmessage_8h.html">syslogmessage::h</a> for the API on the syslog message itself.<p>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-04 0.1 version created.</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Function Documentation</h2>
<a name="a5" doxytag="srAPI.h::srAPICloseLog"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPICloseLog </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a syslog raw session. 
<p>
In the method, we have a slightly different error handling. We do NOT return immediately when something goes wrong but rather preserve the error state and try to continue processing. The reasoning behind this is that we can potentially create an even larger memory leak if we do not try to continue. After all, we are here to free things and shutdown the process. The only exception is when we detect that the caller-provided handle is invalid. In this case, we CAN NOT continue processing.<p>
When this method returns, the the caller-supplied pointer to the API object is NO LONGER VALID and can not be used for consequtive calls.     </td>
  </tr>
</table>
<a name="a6" doxytag="srAPI.h::srAPIExitLib"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPIExitLib </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exit the liblogging library. 
<p>
This method should be called after a higher layer is COMPLETE DONE with liblogging. It does not need to be called after each session close.<p>
if <a class="el" href="srAPI_8h.html#a6">srAPIExitLib()</a> is called, the lib can not be used until <a class="el" href="srAPI_8h.html#a3">srAPIInitLib()</a> is called again.<p>
The provided pointer to the API object is invalid once this method returns.     </td>
  </tr>
</table>
<a name="a13" doxytag="srAPI.h::srAPIGetUsrPointer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPIGetUsrPointer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pAPI</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppToStore</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the user pointer. 
<p>
Returns whatever is stored in pUsr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ppToStore</em>&nbsp;</td><td>Pointer to a pointer that will receive the user pointer. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="srAPI.h::srAPIInitLib"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsrAPIObject.html">srAPIObj</a>* srAPIInitLib </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the liblogging library. 
<p>
This method must be called before any other method.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to an API object (aka "handle") or NULL if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="srAPI.h::srAPIOpenlog"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPIOpenlog </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszRemotePeer</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iPort</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a log session. 
<p>
This API is effectively the initiator side of the RAW profile.<p>
This method looks like much code, but most of it is error handling ;) - so we keep it as a single long method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszRemotePeer</em>&nbsp;</td><td>[in] The Peer to connect to. </td></tr>
    <tr><td valign=top><em>iPort</em>&nbsp;</td><td>[in] The port the remote Peer is listening to.</td></tr>
  </table>
</dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>later, make this depending on the lib option set by the user.</dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="srAPI.h::srAPIRunListener"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPIRunListener </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Run the listener process. 
<p>
Control is only returned if<ul>
<li>a fatal error inside the listener happens</li><li><a class="el" href="srAPI_8h.html#a11">srAPIShutdownListener()</a> has been called</li></ul>
<p>
As control does not return, please note that <a class="el" href="srAPI_8h.html#a11">srAPIShutdownListener()</a> must be called either from another thread or a signal handler.     </td>
  </tr>
</table>
<a name="a7" doxytag="srAPI.h::srAPISendLogmsg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPISendLogmsg </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>szLogmsg</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a log message to the remote peer. 
<p>
The log message must already be correctly formatted according to RFC 3195. No further formatting (or checks) are applied.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in] pointer to a proper srAPI object. </td></tr>
    <tr><td valign=top><em>szLogmsg</em>&nbsp;</td><td>[in] message to be sent. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a8" doxytag="srAPI.h::srAPISendSLMG"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPISendSLMG </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>struct srSLMGObject *&nbsp;</td>
          <td class="mdname" nowrap> <em>pSLMG</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a syslog message object to the remote peer. 
<p>
This method SHOULD be called whenever the caller is already in possesion of a srSLMGObj. Calling srAPISendLogmsg would result in a performance penalty in those cases. In general, you should call this method here whenever you can and use srAPISendLogmsg only in those (rare) cases where you can not avoid it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>[in] pointer to a proper srAPI object. </td></tr>
    <tr><td valign=top><em>pSLMG</em>&nbsp;</td><td>pointer to the syslog message object. This must be a proper object as it will be used as the message source. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a15" doxytag="srAPI.h::srAPISetMsgRcvCallback"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPISetMsgRcvCallback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>NewHandler</em>)(<a class="el" href="structsrAPIObject.html">srAPIObj</a> *, struct srSLMGObject *)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a handler to be called when a syslog message arrives. 
<p>
If this method is called when there already a new handler is set, the previous one is discarded. There can only be a single handler set at a single time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>NewHandler</em>&nbsp;</td><td>Pointer to a function with C calling conventions the will receive the syslog message object as soon as it arrives. This may be NULL. In this case, however, no meaningful work is done. Syslog messages arrive but will be discarded because there is no upper-layer peer. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="srAPI.h::srAPISetOption"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPISetOption </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SRoption&nbsp;</td>
          <td class="mdname" nowrap> <em>iOpt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iOptVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set an library option. 
<p>
Library options provide a way to modify library behaviour. For example, once rfc3195 raw and cooked are implemented, you can set an option to set which transport you would like to have. Consequently, it currently looks like the calling sequence is probably always:<p>
1. srAPIInitLib 2. srAPISetOption 3. srAPIOpenlog 4. srAPISendLogmsg 5. srAPICloselog 6. srAPIExitLib<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pThis</em>&nbsp;</td><td>pointer to the API, as usual. The unusual things is that in this case it may be NULL. If so, global settings will be modified on a per-library basis. </td></tr>
    <tr><td valign=top><em>iOpt</em>&nbsp;</td><td>option to set </td></tr>
    <tr><td valign=top><em>iOptVal</em>&nbsp;</td><td>value that the option is to be set to. The option value is totally dependent on the respective option. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a14" doxytag="srAPI.h::srAPISetupListener"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPISetupListener </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(*&nbsp;</td>
          <td class="mdname" nowrap> <em>NewHandler</em>)(<a class="el" href="structsrAPIObject.html">srAPIObj</a> *, struct srSLMGObject *)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setup the listener for this API object. 
<p>
The listener is initialized but not running. Only a single listener can be active for a single API object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>NewHandler</em>&nbsp;</td><td>Pointer to a function with C calling conventions the will receive the syslog message object as soon as it arrives. This may be NULL. In this case, however, no meaningful work is done. Syslog messages arrive but will be discarded because there is no upper-layer peer. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="srAPI.h::srAPISetUsrPointer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPISetUsrPointer </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pAPI</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>pUsr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the user pointer. 
<p>
Whatever value the user passes in is accepted and stored. No validation is done (and can be done). Any previously stored information is overwritten.     </td>
  </tr>
</table>
<a name="a11" doxytag="srAPI.h::srAPIShutdownListener"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> srAPIShutdownListener </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsrAPIObject.html">srAPIObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shut down the currently running listener. 
<p>
It may take some time to shutdown the listener depending on its current state. The caller should expect a delay of up to 30 seconds.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Sep 12 11:20:14 2003 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
