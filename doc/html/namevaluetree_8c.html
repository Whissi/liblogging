<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: namevaluetree.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>namevaluetree.c File Reference</h1>Implemetation of the NameValueTree helper object (includes XML parser).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;ctype.h&gt;</code><br>
<code>#include "<a class="el" href="config_8h-source.html">config.h</a>"</code><br>
<code>#include "<a class="el" href="liblogging_8h-source.html">liblogging.h</a>"</code><br>
<code>#include "<a class="el" href="namevaluetree_8h-source.html">namevaluetree.h</a>"</code><br>
<code>#include "<a class="el" href="stringbuf_8h-source.html">stringbuf.h</a>"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a1">sbNVTRDestroy</a> (sbNVTRObj *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for root elements - destroys a complete list. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a2">sbNVTEDestroy</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor for entry elements. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="namevaluetree.c::sbNVTXMLEscapePCDATAintoStrB"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbNVTXMLEscapePCDATAintoStrB</b> (char *pszToEscape, <a class="el" href="structsbStrBObject.html">sbStrBObj</a> *pStr)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a12">sbNVTXMLEscapePCDATA</a> (char *pszToEscape)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XML-Escape a string. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>sbNVTRObj *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a16">sbNVTRConstruct</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a NameValueTree Root Object. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a17">sbNVTEConstruct</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a NameValueTree Entry Object. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a18">sbNVTESetChild</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pEntry, sbNVTRObj *pChildRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link a child list to the current entry. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a19">sbNVTAddEntry</a> (sbNVTRObj *pRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an entry to the end of a NameValueTree List. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a20">sbNVTRRemoveFirst</a> (sbNVTRObj *pRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the first entry from a list. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a21">sbNVTUnlinkElement</a> (sbNVTRObj *pRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink the first element from a name value tree. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a22">sbNVTSearchKeySZ</a> (sbNVTRObj *pRoot, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pStart, char *pszSearch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the next element with a given string key inside the list. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a23">sbNVTSearchKeyU</a> (sbNVTRObj *pRoot, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pStart, unsigned uSearch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the next element with a given integer key inside the list. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a24">sbNVTSearchKeyUAndPrev</a> (sbNVTRObj *pRoot, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pStart, unsigned uSearch, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> **ppPrevEntry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is more or less a duplicate of the sbNVTSearchKeyU. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a25">sbNVTSearchpUsrAndPrev</a> (sbNVTRObj *pRoot, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pStart, void *pUsr, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> **ppPrevEntry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method searches for a specific pUsr and returns the entry in question PLUS the previous element. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a26">sbNVTEUtilStrDup</a> (char *pszStrToDup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a string and return it. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a27">sbNVTESetKeySZ</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis, char *pszKey, int bCopy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the string key for a given entry. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a28">sbNVTESetValueSZ</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis, char *pszVal, int bCopy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the string value for a given entry. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a29">sbNVTESetKeyU</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis, unsigned uKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the integer key for a given entry. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a30" doxytag="namevaluetree.c::sbNVTEUnsetKeyU"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a30">sbNVTEUnsetKeyU</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the integer key for a given entry. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a31">sbNVTESetUsrPtr</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis, void *pPtr, void(pPtrDestroy)(void *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the user pointer for a given entry. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a32">sbNVTESetValueU</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis, unsigned uVal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the integer value for a given entry. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a33">sbNVTEGetValueU</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pThis, unsigned *puValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the uValue for this object. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a34">sbNVTEUnsetUsrPtr</a> (<a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pEntry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the user point from an element. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a35">sbNVTRUnlinkFromParent</a> (sbNVTRObj *pRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlinks a root element (complete list) from its parent. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a36">sbNVTEUnlinkFromList</a> (sbNVTRObj *pRoot, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pEntry, <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *pPrev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink an entry from the current list. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a37">sbNVTRRemoveKeyU</a> (sbNVTRObj *pRoot, unsigned uKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a keyed entry from a root element. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a38">sbNVTRRemovEntryWithpUsr</a> (sbNVTRObj *pRoot, void *pUsr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entry with a specific pUsr from a root element. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a39">sbNVTRParseXML</a> (sbNVTRObj *pRoot, char *pszXML)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Populate a NameValueTree based on a BEEP XML stream. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a41">sbNVTDebugPrintTree</a> (sbNVTRObj *pRoot, int iLevel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out a whole tree structure. </em> <a href="#a41"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namevaluetree_8c.html#a42">sbNVTRHasElement</a> (sbNVTRObj *pRoot, char *pEltname, int bMustBeOnly)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a list has the named element. </em> <a href="#a42"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implemetation of the NameValueTree helper object (includes XML parser). 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-04 Initial version as part of liblogging 0.2 begun.</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Function Documentation</h2>
<a name="a19" doxytag="namevaluetree.c::sbNVTAddEntry"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTAddEntry </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pRoot</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add an entry to the end of a NameValueTree List. 
<p>
A new entry element is constructed and added onto the end of the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pRoot</em>&nbsp;</td><td>Root of the list the element is to be added to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to newly created list element or NULL if error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a41" doxytag="namevaluetree.c::sbNVTDebugPrintTree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sbNVTDebugPrintTree </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iLevel</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print out a whole tree structure. 
<p>
This is a debug aid and ONLY AVAILABLE IN DEBUG BUILDS!<p>
We walk the tree and call ourselfs recursively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>iLevel</em>&nbsp;</td><td>- the current level (tree-depth) we are in. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="namevaluetree.c::sbNVTEConstruct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTEConstruct </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a NameValueTree Entry Object. 
<p>
Use this constructor whenever a new object is created!<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to the new object or NULL, if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="namevaluetree.c::sbNVTEDestroy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sbNVTEDestroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor for entry elements. 
<p>
This destructor destroys all elements directly associated with this entry element. As such, XML Properties and Childs are destroyed, but not the parent or sibling, as they may remain valid in another context.<p>
If there is a user pointer, the supplied free() function is called on it.     </td>
  </tr>
</table>
<a name="a33" doxytag="namevaluetree.c::sbNVTEGetValueU"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTEGetValueU </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned *&nbsp;</td>
          <td class="mdname" nowrap> <em>puValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the uValue for this object. 
<p>
If the uValue is already set, it is returned. If it is not yet set, we look at the szValue and see if we can convert it to an uValue. If that succeeds, we return the converted value. If that does not succeed, -1 is returned and an error is flagged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>puValue</em>&nbsp;</td><td>[out] pointer to an unsinged that should receive the uValue. Please note that we can not directly return this as a return value because we need to convey an error state which may happen at any time. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a18" doxytag="namevaluetree.c::sbNVTESetChild"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTESetChild </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pEntry</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pChildRoot</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Link a child list to the current entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pEntry</em>&nbsp;</td><td>Pointer to the entry where the child is to be added. </td></tr>
    <tr><td valign=top><em>pChildRoot</em>&nbsp;</td><td>Pointer to the to-be-added list. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="namevaluetree.c::sbNVTESetKeySZ"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTESetKeySZ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszKey</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bCopy</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the string key for a given entry. 
<p>
The string key is copied to a new buffer if so requested.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszKey</em>&nbsp;</td><td>Pointer to string making up the key. </td></tr>
    <tr><td valign=top><em>bCopy</em>&nbsp;</td><td>TRUE duplicate string, FALSE = use supplied buffer. In case of FALSE, the caller should no longer work with the supplied buffer as ownership moves to the name value tree. Results would be unpredictable at best... </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="namevaluetree.c::sbNVTESetKeyU"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTESetKeyU </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uKey</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the integer key for a given entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>uKey</em>&nbsp;</td><td>new key </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="namevaluetree.c::sbNVTESetUsrPtr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTESetUsrPtr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>pPtr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void(pPtrDestroy&nbsp;</td>
          <td class="mdname" nowrap>)(void *)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the user pointer for a given entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pPtr</em>&nbsp;</td><td>ponter to user supplied buffer </td></tr>
    <tr><td valign=top><em>pPtrDestroy</em>&nbsp;</td><td>pointer to user-supplied method to destroy the buffer. This is necessary as the NameValueTree module may destroy the buffer at any time without the user actually knowing. As such, it must have a destructor. To avaoid coding errors and "too quick" hacks, this pointer is not allowed to be NULL. If you do not need any destructor, provide a pointer to an empty function in this case. The prototype is void Destruct(void* ptr) with ptr being the pinter supplied in pPtr. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="namevaluetree.c::sbNVTESetValueSZ"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTESetValueSZ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszVal</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bCopy</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the string value for a given entry. 
<p>
The string key is copied to a new buffer if so requested.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszVal</em>&nbsp;</td><td>New string to be set. </td></tr>
    <tr><td valign=top><em>bCopy</em>&nbsp;</td><td>TRUE duplicate string, FALSE = use supplied buffer. In case of FALSE, the caller should no longer work with the supplied buffer as ownership moves to the name value tree. Results would be unpredictable at best... </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="namevaluetree.c::sbNVTESetValueU"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTESetValueU </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uVal</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the integer value for a given entry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>uKey</em>&nbsp;</td><td>new value </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="namevaluetree.c::sbNVTEUnlinkFromList"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sbNVTEUnlinkFromList </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pEntry</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pPrev</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlink an entry from the current list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pRoot</em>&nbsp;</td><td>pointer to the root of this list </td></tr>
    <tr><td valign=top><em>pEntry</em>&nbsp;</td><td>pointer to the entry to be unlinked </td></tr>
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to the element immediately before the to be unlinked entry in the list. May be NULL, in which case the to be unlinked element is the first element of the list. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="namevaluetree.c::sbNVTEUnsetUsrPtr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sbNVTEUnsetUsrPtr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pEntry</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove the user point from an element. 
<p>
This is needed if the element got deleted by the user itself. If not done, the list destructor would try to delete the object, thus resulting in a double-free.<p>
If the user pointer is not set, nothing happens.     </td>
  </tr>
</table>
<a name="a26" doxytag="namevaluetree.c::sbNVTEUtilStrDup"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* sbNVTEUtilStrDup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pszStrToDup</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Duplicate a string and return it. 
<p>
This is a general utility, it was just defined first in the context of NVTE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszStrToDup</em>&nbsp;</td><td>String to be duplicated. MUST not be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>duplicated</em>&nbsp;</td><td>string. Must be free()ed if no longer needed. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a16" doxytag="namevaluetree.c::sbNVTRConstruct"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> sbNVTRObj* sbNVTRConstruct </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a NameValueTree Root Object. 
<p>
Use this constructor whenever a new object is created!<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to the new object or NULL, if an error occured. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="namevaluetree.c::sbNVTRDestroy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sbNVTRDestroy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor for root elements - destroys a complete list. 
<p>
So we need to walk it by using the raw pointers.     </td>
  </tr>
</table>
<a name="a42" doxytag="namevaluetree.c::sbNVTRHasElement"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTRHasElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pEltname</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bMustBeOnly</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks if a list has the named element. 
<p>
Can also check if it is the only element in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pEltname</em>&nbsp;</td><td>Name of the element to look for (e.g. "ok") </td></tr>
    <tr><td valign=top><em>bMustBeOnly</em>&nbsp;</td><td>TRUE = must be the only element, FALSE, can be one of many elements. Please note that the only element acutally means the only in this whole list (not the only of this name). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>if</em>&nbsp;</td><td>the element could be found, a pointer to it is returned. NULL is returned if it is not found OR it is not the only entry and bMustBeOnly is TRUE. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="namevaluetree.c::sbNVTRParseXML"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTRParseXML </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszXML</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Populate a NameValueTree based on a BEEP XML stream. 
<p>
This is a mini BEEP XML parser. It parses those constructs supported by BEEP XML. It does NOT check the DTD, this needs to be done by the caller.<p>
This is a "one stop" method, which means that it will do anything needed to do the job. The method detects syntax errors, only. If one is detected, an error state is returned. In this case, the status of the provided NameValueTree structure is undefined - probably some elements have been added, others not. It is highly recommended that the caller discards the NameValueTree structure if this method does not return error-free.<p>
If a pre-populated NameValueTree is provided, the elements found in the XML stream are ADDED to it.<p>
This is a single-pass parser.<p>
ABNF for our Mini XML Parser:<p>
<dl compact><dt><b>Note:</b></dt><dd>This is Pseudo-ABNF, mostly following <a href="http://www.ietf.org/rfc/rfc2234.txt.">http://www.ietf.org/rfc/rfc2234.txt.</a></dd></dl>
BEEPXML = XMLSTREAM XMLSTREAM = *WHITESPACE *XMLELEMENT XMLELEMENT = (XMLNODE / XMLCONTAINER / CDATA) *WHITESPACE CDATA = "&lt;![CDATA[" CDATAVALUE "]]&gt;" ; "CDATA" must be upper case, only. ; Been to lazy to write it down in "right" ABNF ;) XMLNODE = "&lt;" TAGwPARAMS 1*WHITESPACE "/&gt;" ; is it really 1*WHITESPACE or just ; *WHITESPACE? In the implementation, we use *WHITESPACE when reading XMLCONTAINER = "&lt;" TAGwPARAMS "&gt;" (XMLVALUE / XMLSTREAM) "&lt;/" *WHITESPACE TAG "&gt;" ; begin and end tag must be exactly the same. TAGwPARAMS = TAG *(1*WHITESPACE PARAM) *WHITESPACE TAG = XMLNAME PARAM = XMLNAME ["='" XMLVALUE "'"] XMLNAME = NON-WHITESPACE NO "/" / "&lt;" / "&gt;" / "=" / ";" XMLVALUE = *(PRINTABLECHAR / ESCSEQ) CDATAVALUE = all printable chars except "]" WHITESPACE = d09 / d10 / d13 / d32 ; C isspace() PRINTABLECHAR = all printable chars ESCSEQ = "&amp;" XMLNAME ";"<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszXML</em>&nbsp;</td><td>Pointer to a string containing the XML stream. May be NULL, in which case no processing takes place. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="namevaluetree.c::sbNVTRRemoveFirst"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTRRemoveFirst </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pRoot</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the first entry from a list. 
<p>
The entry will be unlinked and then destroyed. It is valid to call this function on an empty list. In this case, nothing will happen.     </td>
  </tr>
</table>
<a name="a37" doxytag="namevaluetree.c::sbNVTRRemoveKeyU"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTRRemoveKeyU </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uKey</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a keyed entry from a root element. 
<p>
The key search is done on the unsigned key. The first entry with a matching key value is removed. Do not use this method on a list with potentially multiple keys of the same value - or be sure to know EXACTLY what you are doing and why...<p>
The entry shall not only be unlinked from the tree but also destroyed.     </td>
  </tr>
</table>
<a name="a38" doxytag="namevaluetree.c::sbNVTRRemovEntryWithpUsr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbNVTRRemovEntryWithpUsr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>pUsr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove an entry with a specific pUsr from a root element. 
<p>
The first entry with a matching pUsr is removed. Do not use this method on a list with potentially multiple identical pUsrs - or be sure to know EXACTLY what you are doing and why...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pUsr</em>&nbsp;</td><td>The pUsr to find and delete. This may be NULL but keep the above warning about multiple values in mind!</td></tr>
  </table>
</dl>
The entry shall not only be unlinked from the tree but also be destroyed.     </td>
  </tr>
</table>
<a name="a35" doxytag="namevaluetree.c::sbNVTRUnlinkFromParent"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void sbNVTRUnlinkFromParent </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pRoot</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlinks a root element (complete list) from its parent. 
<p>
If the root element has no parent, nothing happens. This is no error.     </td>
  </tr>
</table>
<a name="a22" doxytag="namevaluetree.c::sbNVTSearchKeySZ"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTSearchKeySZ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>pszSearch</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the next element with a given string key inside the list. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>A list may contain multiple entries with the same key. As such, this method receives a pointer to the last entry found and continues search from there. Call the method until NULL is returned, in which case no further match is found.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pRoot</em>&nbsp;</td><td>Root of the list to be searched. </td></tr>
    <tr><td valign=top><em>pStart</em>&nbsp;</td><td>Starting entry for the search. If NULL, search will begin at the first entry. Please note that pStart MUST belong to pRoot, otherwise results are unpredictable. </td></tr>
    <tr><td valign=top><em>pszSearch</em>&nbsp;</td><td>String to search for. If this pointer is NULL, the next element is returned without any comparision. In short, with this parameter being NULL, the method can be used to walk the list. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to found element or NULL, if no (more) element is found. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="namevaluetree.c::sbNVTSearchKeyU"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTSearchKeyU </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uSearch</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the next element with a given integer key inside the list. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>A list may contain multiple entries with the same key. As such, this method receives a pointer to the last entry found and continues search from there. Call the method until NULL is returned, in which case no further match is found.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pRoot</em>&nbsp;</td><td>Root of the list to be searched. </td></tr>
    <tr><td valign=top><em>pStart</em>&nbsp;</td><td>Starting entry for the search. If NULL, search will begin at the first entry. Please note that pStart MUST belong to pRoot, otherwise results are unpredictable. </td></tr>
    <tr><td valign=top><em>uSearch</em>&nbsp;</td><td>Unsinged Integer to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to found element or NULL, if no (more) element is found. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="namevaluetree.c::sbNVTSearchKeyUAndPrev"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTSearchKeyUAndPrev </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uSearch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppPrevEntry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is more or less a duplicate of the sbNVTSearchKeyU. 
<p>
The difference is that this method also delivers back the previous entry. This is done for performance reasons - it saves us from doubly-linking the list, which would otherwise be required and for sure be overdone in the current state of affairs.<p>
AllParams are like sbNVTSearchKeyU plus <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ppPrevEntry</em>&nbsp;</td><td>Pointer to a pointer to the previous element. This is needed so that that element can be updated during unlink operations. Is NULL if there is no previous element. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="namevaluetree.c::sbNVTSearchpUsrAndPrev"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTSearchpUsrAndPrev </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRoot</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pStart</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>pUsr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structsbNVTEObject.html">sbNVTEObj</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppPrevEntry</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This method searches for a specific pUsr and returns the entry in question PLUS the previous element. 
<p>
This is done for performance reasons - it saves us from doubly-linking the list, which would otherwise be required and for sure be overdone in the current state of affairs.<p>
<dl compact><dt><b>Note:</b></dt><dd>A list may contain multiple entries with the same key. As such, this method receives a pointer to the last entry found and continues search from there. Call the method until NULL is returned, in which case no further match is found.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pRoot</em>&nbsp;</td><td>Root of the list to be searched. </td></tr>
    <tr><td valign=top><em>pStart</em>&nbsp;</td><td>Starting entry for the search. If NULL, search will begin at the first entry. Please note that pStart MUST belong to pRoot, otherwise results are unpredictable. </td></tr>
    <tr><td valign=top><em>pUsr</em>&nbsp;</td><td>pUsr to search for. </td></tr>
    <tr><td valign=top><em>ppPrevEntry</em>&nbsp;</td><td>Pointer to a pointer to the previous element. This is needed so that that element can be updated during unlink operations. Is NULL if there is no previous element. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to found element or NULL, if no (more) element is found. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="namevaluetree.c::sbNVTUnlinkElement"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbNVTEObject.html">sbNVTEObj</a>* sbNVTUnlinkElement </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">sbNVTRObj *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pRoot</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlink the first element from a name value tree. 
<p>
The element is not destroyed, but simply unlinked. <dl compact><dt><b>Note:</b></dt><dd>It is the caller's responsibility to unlink the element when he is done!</dd></dl>
It is valid to call this mothod on a linked list WITHOUT any elements. In this case, NULL is returned.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pointer</em>&nbsp;</td><td>to unlinked element or NULL if list was empty. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a12" doxytag="namevaluetree.c::sbNVTXMLEscapePCDATA"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char* sbNVTXMLEscapePCDATA </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pszToEscape</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XML-Escape a string. 
<p>
The resulting string is suitable for use in #pcdata, that is as a string BETWEEN XML tags (e.g. string. It is NOT suitable to be used inside a tag parameter (e.g. ).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pszToEscape</em>&nbsp;</td><td>The string to be escaped. Should not be NULL. If it is NULL, the return value will also be NULL. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to an XML-escaped string or NULL, if no memory for that string could be allocated. IMPORTANT: the caller MUST free() that buffer once he is done with the string, otherwise a memory leak will be left. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Sep 12 11:20:14 2003 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
