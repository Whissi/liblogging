<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>liblogging: sockets.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>sockets.c File Reference</h1>Implements the socket object.  
<a href="#_details">More...</a>
<p>
<code>#include "<a class="el" href="config_8h-source.html">config.h</a>"</code><br>
<code>#include "<a class="el" href="liblogging_8h-source.html">liblogging.h</a>"</code><br>
<code>#include "<a class="el" href="sockets_8h-source.html">sockets.h</a>"</code><br>
<code>#include "assert.h"</code><br>
<code>#include "<a class="el" href="socketsUnix_8c.html">socketsUnix.c</a>"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="sockets.c::sbSockConstruct"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a1">sbSockConstruct</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> **pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a socket object (just in-memory representation, no socket calls). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a2">sbSockGetLastSockError</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get last error code </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a3">sbSockPeekRcvChar</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the next character from the stream. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a4">sbSockGetRcvChar</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the next character from the stream. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="sockets.c::sbSockExit"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>sbSockExit</b> (struct <a class="el" href="structsbSockObject.html">sbSockObject</a> *pThis)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="sockets.c::sbSockHasReceiveData"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>sbSockHasReceiveData</b> (struct <a class="el" href="structsbSockObject.html">sbSockObject</a> *pThis)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a7">sbSockWaitReceiveData</a> (struct <a class="el" href="structsbSockObject.html">sbSockObject</a> *pThis)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until the socket has some receive data. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a8">sbSockInitListenSock</a> (<a class="el" href="liblogging_8h.html#a6">srRetVal</a> *iRet, char *szBindToAddress, unsigned uBindToPort)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a listen socket. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="sockets.c::sbSockAcceptConnection"></a>
<a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a9">sbSockAcceptConnection</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, <a class="el" href="structsbSockObject.html">sbSockObj</a> **pNew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method accepts an incoming connection and creates a new socket object out of it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a10">sbSockGetRemoteHostIP</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, char **ppszHost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the IP Address of the remote host as a string. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="liblogging_8h.html#a6">srRetVal</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="sockets_8c.html#a11">sbSockGetIPusedForSending</a> (<a class="el" href="structsbSockObject.html">sbSockObj</a> *pThis, char **ppsz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide the (local) IP address this session is sending to the remote peer on as a string. </em> <a href="#a11"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implements the socket object. 
<p>
This file implements the socket layer. It contains all those methods that are upper layer. It also includes lower layer files which do the actual OS-dependant socket API handling. Thanks to Devin Kowatch, there is now a UNIX as well as a Win32 lower layer available.<p>
<dl compact><dt><b>Note:</b></dt><dd>If you intend to add a new lower layer, please<ul>
<li>create a new file socketsXXX.c, where XXX is the OS dependant name.</li><li>update the conditional compilation at the end of this file to include your new lower layer.</li></ul>
</dd></dl>
<dl compact><dt><b>Author:</b></dt><dd>Rainer Gerhards &lt;<a href="mailto:rgerhards@adiscon.com">rgerhards@adiscon.com</a>&gt; </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>2003-08-05 Created this file as upper-layer and general entry point to the socket object. It includes the necessry lower layer according to the <a class="el" href="config_8h.html">config.h</a> OS defines.</dd></dl>
Copyright 2002-2003 Rainer Gerhards and Adiscon GmbH. All Rights Reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of Adiscon GmbH or Rainer Gerhards nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<hr><h2>Function Documentation</h2>
<a name="a11" doxytag="sockets.c::sbSockGetIPusedForSending"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockGetIPusedForSending </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppsz</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Provide the (local) IP address this session is sending to the remote peer on as a string. 
<p>
OK, the short description is probably not very well ;) What it does is, it looks up the local IP address that is used to talk to the remote Peer. This is especially important on multihomed machines, as different interfaces can be used to forward data (depending on which one is closest to the recipient). Then, it formats this as an IP Address string that then is handed back to the caller.<p>
Please note: the socket MUST be connected before you can use this method! It should NOT be used on UDP sockets.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>ppsz</em>&nbsp;</td><td>Pointer to a char* that will receive the IP string. The caller must free the returned pointer when he is done. The provided pointer must not be NULL. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="sockets.c::sbSockGetLastSockError"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockGetLastSockError </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
get last error code 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>last</em>&nbsp;</td><td>error code (OS specific) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="sockets.c::sbSockGetRcvChar"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockGetRcvChar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the next character from the stream. 
<p>
The character is removed from the stream. If no data is ready on the stream, a blocking read is carried out. So this function can block!<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>character</em>&nbsp;</td><td>read </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="sockets.c::sbSockGetRemoteHostIP"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockGetRemoteHostIP </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pThis</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>ppszHost</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the IP Address of the remote host as a string. 
<p>
The caller must free the returned string.     </td>
  </tr>
</table>
<a name="a8" doxytag="sockets.c::sbSockInitListenSock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structsbSockObject.html">sbSockObj</a>* sbSockInitListenSock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="liblogging_8h.html#a6">srRetVal</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>iRet</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>szBindToAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>uBindToPort</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a listen socket. 
<p>
This includes everything so that the next call can be listen().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>iRet</em>&nbsp;</td><td>[out] Pointer to a variable holding the return code of this operation. Has the error code if initialisation failed. </td></tr>
    <tr><td valign=top><em>szBindToAdresse</em>&nbsp;</td><td>string with IP address to which the socket should be bound. If NULL, do not bind to any specific address. </td></tr>
    <tr><td valign=top><em>iBindToPort</em>&nbsp;</td><td>Port the socket should be bound to. For listening sockets, this is the port that the remote peer will to connect to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>Pointer</em>&nbsp;</td><td>to newly created socket or NULL, if an error occured. In case of NULL, the caller can examine the socket error code to learn the error cause. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="sockets.c::sbSockPeekRcvChar"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int sbSockPeekRcvChar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structsbSockObject.html">sbSockObj</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the next character from the stream. 
<p>
The character is NOT removed from the stream. If no data is ready on the stream, a blocking read is carried out. So this function can block!<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>character</em>&nbsp;</td><td>read </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a7" doxytag="sockets.c::sbSockWaitReceiveData"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="liblogging_8h.html#a6">srRetVal</a> sbSockWaitReceiveData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct <a class="el" href="structsbSockObject.html">sbSockObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pThis</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait until the socket has some receive data. 
<p>
This is a blocking call.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Sep 12 11:20:14 2003 for liblogging by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
